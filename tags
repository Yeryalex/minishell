!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/rbuitrag/Documents/Cursus42/Circle_3/Minishell/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(NAME)	Makefile	/^$(NAME): $(OBJS)$/;"	t
$(NAME)	inc/libft/Makefile	/^$(NAME): $(OFILES)$/;"	t
%.o	Makefile	/^%.o: %.c $(HEADER) Makefile$/;"	t
%.o	inc/libft/Makefile	/^%.o:%.c $(HEADER) Makefile$/;"	t
0	.vscode/launch.json	/^	  {$/;"	o	array:configurations
0	.vscode/tasks.json	/^		"problemMatcher": ["$gcc"],$/;"	s	array:tasks.0.problemMatcher
0	.vscode/tasks.json	/^	  {$/;"	o	array:tasks
APPEND	inc/minishell.h	/^	APPEND, \/\/ >> $/;"	e	enum:e_type
Análisis lexicológico	README.md	/^# Análisis lexicológico$/;"	c
Análisis sintáctico	README.md	/^# Análisis sintáctico$/;"	c
BLUE	inc/minishell.h	/^# define BLUE /;"	d
CC	inc/libft/Makefile	/^CC = cc$/;"	m
CFILES	Makefile	/^CFILES =	main.c \\$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -Werror -Wextra$/;"	m
CYAN	inc/minishell.h	/^# define CYAN /;"	d
Comando único	README.md	/^# Comando único$/;"	c
Copiado e inspirado este pedazo de tutorial, de dos grandes entre otros:	README.md	/^# Copiado e inspirado este pedazo de tutorial, de dos grandes entre otros:$/;"	c
Deberá implementar los built-ins:	README.md	/^# Deberá implementar los built-ins:$/;"	c
Documentación	README.md	/^# Documentación$/;"	c
Ejecución	README.md	/^# Ejecución$/;"	c
Ejecutor	README.md	/^# Ejecutor$/;"	c
El analizador	README.md	/^# El analizador$/;"	c
Elementos incorporados	README.md	/^# Elementos incorporados$/;"	c
Empezando a comprender lo que se debe hacer	README.md	/^# Empezando a comprender lo que se debe hacer$/;"	c
Expansiones	README.md	/^# Expansiones$/;"	c
Expansor	README.md	/^# Expansor$/;"	c
FILES	inc/libft/Makefile	/^FILES =  ft_strlen.c ft_memset.c ft_isprint.c ft_isdigit.c \\$/;"	m
FLAGS	inc/libft/Makefile	/^FLAGS = -Wall -Wextra -Werror -c$/;"	m
GRAY	inc/minishell.h	/^# define GRAY /;"	d
GREEN	Makefile	/^GREEN = "\\033[92m"$/;"	m
GREEN	inc/minishell.h	/^# define GREEN /;"	d
GTHAN	inc/minishell.h	/^	GTHAN, \/\/ >$/;"	e	enum:e_type
HEADER	Makefile	/^HEADER = inc\/minishell.h $/;"	m
HEADER	inc/libft/Makefile	/^HEADER = libft.h$/;"	m
H_DOC	inc/minishell.h	/^	H_DOC, \/\/ << HEREDOC$/;"	e	enum:e_type
Heredoc	README.md	/^# Heredoc$/;"	c
LIBFT	Makefile	/^LIBFT = inc\/libft\/libft.a$/;"	m
LIBFT_H	inc/libft/libft.h	/^# define LIBFT_H$/;"	d
Las funciones incorporadas (según el tema) son:	README.md	/^# Las funciones incorporadas (según el tema) son:$/;"	c
Lectura del input	README.md	/^# Lectura del input$/;"	c
MAGENTA	inc/minishell.h	/^# define MAGENTA /;"	d
MIMode	.vscode/launch.json	/^		"MIMode": "gdb",$/;"	s	object:configurations.0
MINISHELL_H	inc/minishell.h	/^# define MINISHELL_H$/;"	d
Mapa mental (todo lo anterior en imagen)	README.md	/^# Mapa mental (todo lo anterior en imagen)$/;"	c
Mas informacion de los procesos a realizar	README.md	/^# Mas informacion de los procesos a realizar$/;"	c
Minishell debe:	README.md	/^# Minishell debe: $/;"	c
Minishell-42	README.md	/^# Minishell-42$/;"	c
Más resources	README.md	/^# Más resources$/;"	c
NAME	Makefile	/^NAME = minishell$/;"	m
NAME	inc/libft/Makefile	/^NAME = libft.a$/;"	m
NONE	inc/minishell.h	/^	NONE,$/;"	e	enum:e_type
OBJS	Makefile	/^OBJS = $(addprefix src\/, $(CFILES:.c=.o))$/;"	m
OFILES	inc/libft/Makefile	/^OFILES = $(FILES:.c=.o)$/;"	m
PIPE	inc/minishell.h	/^	PIPE,  \/\/ |$/;"	e	enum:e_type
Proceso	README.md	/^# Proceso$/;"	c
RED	inc/minishell.h	/^# define RED /;"	d
RESET	Makefile	/^RESET = "\\033[0m"$/;"	m
RESET	inc/minishell.h	/^# define RESET /;"	d
Redirecciones y liberación de memoria	README.md	/^# Redirecciones y liberación de memoria$/;"	c
Reiniciar	README.md	/^# Reiniciar$/;"	c
STHAN	inc/minishell.h	/^	STHAN, \/\/ <$/;"	e	enum:e_type
Uso	README.md	/^# Uso$/;"	c
Uso de Valgrind en el programa (sube el archivo <readline.ignore> para probar los leaks sin los errores de readline	README.md	/^# Uso de Valgrind en el programa (sube el archivo <readline.ignore> para probar los leaks sin lo/;"	c
WORD	inc/minishell.h	/^	WORD,$/;"	e	enum:e_type
YELLOW	inc/minishell.h	/^# define YELLOW /;"	d
all	Makefile	/^all: library $(NAME)$/;"	t
all	inc/libft/Makefile	/^all : $(NAME)$/;"	t
check_env	inc/minishell.h	/^	int				check_env;$/;"	m	struct:s_utils	typeref:typename:int
clean	Makefile	/^clean:$/;"	t
clean	inc/libft/Makefile	/^clean:$/;"	t
cmd_array	inc/minishell.h	/^	char			**cmd_array;$/;"	m	struct:s_cmds	typeref:typename:char **
command	.vscode/tasks.json	/^		"command": "make", $/;"	s	object:tasks.0
configurations	.vscode/launch.json	/^	"configurations": [$/;"	a
count_digit	inc/libft/ft_itoa.c	/^static size_t	count_digit(int n)$/;"	f	typeref:typename:size_t	file:
count_substrings	src/expanser/split_path.c	/^static int count_substrings(const char *str, char delimiter)$/;"	f	typeref:typename:int	file:
cwd	.vscode/launch.json	/^		"cwd": "${workspaceFolder}",  \/\/ Directorio de trabajo$/;"	s	object:configurations.0
detail	.vscode/tasks.json	/^		"detail": "Tarea para compilar el proyecto minishell"$/;"	s	object:tasks.0
e_type	inc/minishell.h	/^typedef enum e_type$/;"	g
engineLogging	.vscode/launch.json	/^		  "engineLogging": true,$/;"	b	object:configurations.0.logging
environ	inc/minishell.h	/^	t_env 			*environ;$/;"	m	struct:s_utils	typeref:typename:t_env *
execute_commands	src/expanser/utils_expanser.c	/^void    execute_commands(t_cmds *cmd, char **env)$/;"	f	typeref:typename:void
exported	inc/minishell.h	/^	int				exported;$/;"	m	struct:s_env	typeref:typename:int
externalConsole	.vscode/launch.json	/^		"externalConsole": false,$/;"	b	object:configurations.0
fclean	Makefile	/^fclean: clean$/;"	t
fclean	inc/libft/Makefile	/^fclean: clean$/;"	t
fd	inc/minishell.h	/^	int		fd;$/;"	m	struct:s_dir	typeref:typename:int
fd_in	inc/minishell.h	/^	t_dir			*fd_in;$/;"	m	struct:s_cmds	typeref:typename:t_dir *
fd_out	inc/minishell.h	/^	t_dir			*fd_out;$/;"	m	struct:s_cmds	typeref:typename:t_dir *
filename	inc/minishell.h	/^	char	*filename;$/;"	m	struct:s_dir	typeref:typename:char *
files.associations	.vscode/settings.json	/^	"files.associations": {$/;"	o
ft_add_env_tolst	src/utils/init_env.c	/^void	ft_add_env_tolst(t_env **lst_env, t_env *new_node)$/;"	f	typeref:typename:void
ft_addlast_node	src/lexer/lexer_utils.c	/^int	ft_addlast_node(t_tokens **lexer, t_tokens *current_node)$/;"	f	typeref:typename:int
ft_atoi	inc/libft/ft_atoi.c	/^int	ft_atoi(const char *str)$/;"	f	typeref:typename:int
ft_bzero	inc/libft/ft_bzero.c	/^void	ft_bzero(void *s, size_t n)$/;"	f	typeref:typename:void
ft_calloc	inc/libft/ft_calloc.c	/^void	*ft_calloc(size_t count, size_t size)$/;"	f	typeref:typename:void *
ft_clear_lstenv	src/utils/init_env.c	/^int	ft_clear_lstenv(t_env *envs)$/;"	f	typeref:typename:int
ft_count_words	inc/libft/ft_split.c	/^static int	ft_count_words(const char *s, char c)$/;"	f	typeref:typename:int	file:
ft_cpy_strs	inc/libft/ft_split.c	/^static char	**ft_cpy_strs(char **strs, const char *s, char c)$/;"	f	typeref:typename:char **	file:
ft_create_node	src/lexer/prompt.c	/^t_tokens	*ft_create_node(const char **input)$/;"	f	typeref:typename:t_tokens *
ft_create_node_cmd	src/parser/parser.c	/^t_cmds *ft_create_node_cmd(t_tokens *lexer, int count, char *path)$/;"	f	typeref:typename:t_cmds *
ft_create_node_env	src/utils/init_env.c	/^t_env	*ft_create_node_env(char *envs)$/;"	f	typeref:typename:t_env *
ft_determine_type	src/lexer/prompt.c	/^t_type	ft_determine_type(char *value)$/;"	f	typeref:typename:t_type
ft_dup_close	src/executor/ft_executor.c	/^void	ft_dup_close(t_cmds *cmd, int prev_read, int *fd)$/;"	f	typeref:typename:void
ft_executor	src/executor/ft_executor.c	/^void	ft_executor(t_cmds *current, t_utils *utils, char **env)$/;"	f	typeref:typename:void
ft_exit_error	src/lexer/lexer_utils.c	/^void	*ft_exit_error(char quote)$/;"	f	typeref:typename:void *
ft_forking	src/executor/ft_executor.c	/^int	ft_forking(t_cmds *cmd, int	prev_read, int *fd, char **env)$/;"	f	typeref:typename:int
ft_free_array	src/expanser/utils_expanser.c	/^static void ft_free_array(char **array)$/;"	f	typeref:typename:void	file:
ft_free_tokens	src/lexer/lexer_utils.c	/^void	ft_free_tokens(t_tokens **head)$/;"	f	typeref:typename:void
ft_get_env_key	src/utils/env_export.c	/^char	*ft_get_env_key(char *str)$/;"	f	typeref:typename:char *
ft_get_env_value	src/utils/env_export.c	/^char	*ft_get_env_value(char *key_value)$/;"	f	typeref:typename:char *
ft_get_path	src/expanser/utils_expanser.c	/^char    *ft_get_path(char *path, char *cmd) \/\/ full_path, cmd->cmd_array[0]$/;"	f	typeref:typename:char *
ft_get_paths_from_env	src/expanser/utils_expanser.c	/^char	*ft_get_paths_from_env(t_env *environ)$/;"	f	typeref:typename:char *
ft_get_value	src/lexer/lexer_utils.c	/^char	*ft_get_value(const char **input)$/;"	f	typeref:typename:char *
ft_get_word	src/lexer/lexer_utils.c	/^char	*ft_get_word(const char **input)$/;"	f	typeref:typename:char *
ft_init_env	src/utils/init_env.c	/^t_env		*ft_init_env(char **envs)$/;"	f	typeref:typename:t_env *
ft_is_metacharacter	src/lexer/lexer_utils.c	/^int	ft_is_metacharacter(int c)$/;"	f	typeref:typename:int
ft_isalnum	inc/libft/ft_isalnum.c	/^int	ft_isalnum(int c)$/;"	f	typeref:typename:int
ft_isalpha	inc/libft/ft_isalpha.c	/^int	ft_isalpha(int c)$/;"	f	typeref:typename:int
ft_isascii	inc/libft/ft_isascii.c	/^int	ft_isascii(int c)$/;"	f	typeref:typename:int
ft_isdigit	inc/libft/ft_isdigit.c	/^int	ft_isdigit(int c)$/;"	f	typeref:typename:int
ft_isprint	inc/libft/ft_isprint.c	/^int	ft_isprint(int c)$/;"	f	typeref:typename:int
ft_isspace	src/lexer/prompt.c	/^int	ft_isspace(char c)$/;"	f	typeref:typename:int
ft_itoa	inc/libft/ft_itoa.c	/^char	*ft_itoa(int n)$/;"	f	typeref:typename:char *
ft_lexer_input	src/lexer/prompt.c	/^t_tokens	*ft_lexer_input(const char *input)$/;"	f	typeref:typename:t_tokens *
ft_list_to_char	src/lexer/prompt.c	/^char **ft_list_to_char(t_env *env)$/;"	f	typeref:typename:char **
ft_lstsize	src/lexer/prompt.c	/^static int ft_lstsize(t_env *env)$/;"	f	typeref:typename:int	file:
ft_malloc_strs	inc/libft/ft_split.c	/^static char	**ft_malloc_strs(char **strs, const char *s, char c)$/;"	f	typeref:typename:char **	file:
ft_memchr	inc/libft/ft_memchr.c	/^void	*ft_memchr(const void *s, int c, int n)$/;"	f	typeref:typename:void *
ft_memcmp	inc/libft/ft_memcmp.c	/^int	ft_memcmp(const void *s1, const void *s2, size_t n)$/;"	f	typeref:typename:int
ft_memcpy	inc/libft/ft_memcpy.c	/^void	*ft_memcpy(void *dest, const void *src, size_t count)$/;"	f	typeref:typename:void *
ft_memmove	inc/libft/ft_memmove.c	/^void	*ft_memmove(void *dst, const void *src, size_t len)$/;"	f	typeref:typename:void *
ft_memset	inc/libft/ft_memset.c	/^void	*ft_memset(void *dest, int c, size_t count)$/;"	f	typeref:typename:void *
ft_merror	inc/libft/ft_split.c	/^static char	**ft_merror(char **strs)$/;"	f	typeref:typename:char **	file:
ft_parser	src/parser/parser.c	/^t_cmds *ft_parser(t_tokens *lexer, char *path)$/;"	f	typeref:typename:t_cmds *
ft_print_env_list	src/utils/env_export.c	/^void ft_print_env_list(t_env *envs)$/;"	f	typeref:typename:void
ft_print_stderr	src/utils/env_export.c	/^void	*ft_print_stderr(char *str)$/;"	f	typeref:typename:void *
ft_putchar_fd	inc/libft/ft_putchar_fd.c	/^void	ft_putchar_fd(char c, int fd)$/;"	f	typeref:typename:void
ft_putendl_fd	inc/libft/ft_putendl_fd.c	/^void	ft_putendl_fd(char *s, int fd)$/;"	f	typeref:typename:void
ft_putnbr_fd	inc/libft/ft_putnbr_fd.c	/^void	ft_putnbr_fd(int n, int fd)$/;"	f	typeref:typename:void
ft_putstr_fd	inc/libft/ft_putstr_fd.c	/^void	ft_putstr_fd(char *s, int fd)$/;"	f	typeref:typename:void
ft_reset_read_end	src/executor/ft_executor.c	/^void	ft_reset_read_end(t_cmds *current, int *prev_read, int *fd)$/;"	f	typeref:typename:void
ft_search_c	inc/libft/ft_strtrim.c	/^static	int	ft_search_c(char c, const char *set)$/;"	f	typeref:typename:int	file:
ft_split	inc/libft/ft_split.c	/^char	**ft_split(char const *s, char c)$/;"	f	typeref:typename:char **
ft_split_path	src/expanser/split_path.c	/^char **ft_split_path(const char *path)$/;"	f	typeref:typename:char **
ft_strchr	inc/libft/ft_strchr.c	/^char	*ft_strchr(const char *s, int c)$/;"	f	typeref:typename:char *
ft_strdup	inc/libft/ft_strdup.c	/^char	*ft_strdup(const char *s1)$/;"	f	typeref:typename:char *
ft_striteri	inc/libft/ft_striteri.c	/^void	ft_striteri(char *s, void (*f)(unsigned int, char*))$/;"	f	typeref:typename:void
ft_strjoin	inc/libft/ft_strjoin.c	/^char	*ft_strjoin(const char *s1, const char *s2)$/;"	f	typeref:typename:char *
ft_strlcat	inc/libft/ft_strlcat.c	/^size_t	ft_strlcat(char	*dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_strlcpy	inc/libft/ft_strlcpy.c	/^size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)$/;"	f	typeref:typename:size_t
ft_strlen	inc/libft/ft_strlen.c	/^size_t	ft_strlen(const char *str)$/;"	f	typeref:typename:size_t
ft_strmapi	inc/libft/ft_strmapi.c	/^char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))$/;"	f	typeref:typename:char *
ft_strncmp	inc/libft/ft_strncmp.c	/^int	ft_strncmp(const char *s1, const char *s2, size_t n)$/;"	f	typeref:typename:int
ft_strnstr	inc/libft/ft_strnstr.c	/^char	*ft_strnstr(const char *src, const char *sfind, size_t len)$/;"	f	typeref:typename:char *
ft_strrchr	inc/libft/ft_strrchr.c	/^char	*ft_strrchr(const char *s, int c)$/;"	f	typeref:typename:char *
ft_strtrim	inc/libft/ft_strtrim.c	/^char	*ft_strtrim(const char *s1, const char *set)$/;"	f	typeref:typename:char *
ft_substr	inc/libft/ft_substr.c	/^char	*ft_substr(const char *s, unsigned int start, size_t len)$/;"	f	typeref:typename:char *
ft_tolower	inc/libft/ft_tolower.c	/^int	ft_tolower(int c)$/;"	f	typeref:typename:int
ft_toupper	inc/libft/ft_toupper.c	/^int	ft_toupper(int c)$/;"	f	typeref:typename:int
full_path	inc/minishell.h	/^	char			*full_path;$/;"	m	struct:s_cmds	typeref:typename:char *
get_env_value	src/expanser/utils_expanser.c	/^static char	*get_env_value(t_env *env, char *key)$/;"	f	typeref:typename:char *	file:
group	.vscode/tasks.json	/^		"group": {$/;"	o	object:tasks.0
heredoc	inc/minishell.h	/^	int		heredoc;$/;"	m	struct:s_dir	typeref:typename:int
isDefault	.vscode/tasks.json	/^		  "isDefault": true$/;"	b	object:tasks.0.group
key	inc/minishell.h	/^	char			*key;$/;"	m	struct:s_env	typeref:typename:char *
kind	.vscode/tasks.json	/^		  "kind": "build",$/;"	s	object:tasks.0.group
label	.vscode/tasks.json	/^		"label": "compilar",$/;"	s	object:tasks.0
library	Makefile	/^library:$/;"	t
logging	.vscode/launch.json	/^		"logging": {$/;"	o	object:configurations.0
main	src/main.c	/^int main(int ac, char **argv, char **env)$/;"	f	typeref:typename:int
make_copy	inc/libft/ft_memmove.c	/^static void	*make_copy(unsigned char *dst, const unsigned char *src, size_t len)$/;"	f	typeref:typename:void *	file:
makefile.configureOnOpen	.vscode/settings.json	/^	"makefile.configureOnOpen": false$/;"	b
malloc_error	inc/libft/ft_substr.c	/^static char	*malloc_error(size_t len_malloc)$/;"	f	typeref:typename:char *	file:
miDebuggerPath	.vscode/launch.json	/^		"miDebuggerPath": "\/usr\/bin\/gdb",  \/\/ Ruta del depurador (puede variar según el sistema)$/;"	s	object:configurations.0
minishell.h	.vscode/settings.json	/^		"minishell.h": "c"$/;"	s	object:files.associations
name	.vscode/launch.json	/^		"name": "Debug Minishell",$/;"	s	object:configurations.0
next	inc/minishell.h	/^	struct s_cmds 	*next;$/;"	m	struct:s_cmds	typeref:struct:s_cmds *
next	inc/minishell.h	/^	struct s_env	*next;$/;"	m	struct:s_env	typeref:struct:s_env *
next	inc/minishell.h	/^	struct s_tokens	*next;$/;"	m	struct:s_tokens	typeref:struct:s_tokens *
next	inc/minishell.h	/^	struct s_utils	*next;$/;"	m	struct:s_utils	typeref:struct:s_utils *
preLaunchTask	.vscode/launch.json	/^		"preLaunchTask": "compilar",  \/\/ Nombre de la tarea de compilación$/;"	s	object:configurations.0
prev	inc/minishell.h	/^	struct s_cmds	*prev;$/;"	m	struct:s_cmds	typeref:struct:s_cmds *
prev	inc/minishell.h	/^	struct s_tokens	*prev;$/;"	m	struct:s_tokens	typeref:struct:s_tokens *
prev	inc/minishell.h	/^	struct s_utils	*prev;$/;"	m	struct:s_utils	typeref:struct:s_utils *
print_find_cmd	src/parser/parser.c	/^void print_find_cmd(t_cmds	*find_cmd)$/;"	f	typeref:typename:void
print_num	inc/libft/ft_putnbr_fd.c	/^static void	print_num(int n2, int fd2)$/;"	f	typeref:typename:void	file:
problemMatcher	.vscode/tasks.json	/^		"problemMatcher": ["$gcc"],$/;"	a	object:tasks.0
program	.vscode/launch.json	/^		"program": "${workspaceFolder}\/minishell",  \/\/ Ruta del ejecutable$/;"	s	object:configurations.0
prompt_loop	src/lexer/prompt.c	/^void	prompt_loop(t_env *environ, char *path)$/;"	f	typeref:typename:void
re	Makefile	/^re: fclean all$/;"	t
re	inc/libft/Makefile	/^re : fclean all$/;"	t
read_input	src/lexer/prompt.c	/^char	*read_input(void)$/;"	f	typeref:typename:char *
request	.vscode/launch.json	/^		"request": "launch",$/;"	s	object:configurations.0
s_cmds	inc/minishell.h	/^typedef struct s_cmds$/;"	s
s_dir	inc/minishell.h	/^typedef struct s_dir$/;"	s
s_env	inc/minishell.h	/^typedef struct s_env$/;"	s
s_tokens	inc/minishell.h	/^typedef struct s_tokens$/;"	s
s_utils	inc/minishell.h	/^typedef struct s_utils$/;"	s
stdin	inc/minishell.h	/^	int				stdin;$/;"	m	struct:s_utils	typeref:typename:int
stdout	inc/minishell.h	/^	int				stdout;$/;"	m	struct:s_utils	typeref:typename:int
substring	src/expanser/split_path.c	/^static char *substring(const char *start, const char *end)$/;"	f	typeref:typename:char *	file:
t_cmds	inc/minishell.h	/^} t_cmds;$/;"	t	typeref:struct:s_cmds
t_dir	inc/minishell.h	/^}	t_dir;$/;"	t	typeref:struct:s_dir
t_env	inc/minishell.h	/^}	t_env;$/;"	t	typeref:struct:s_env
t_tokens	inc/minishell.h	/^}	t_tokens;$/;"	t	typeref:struct:s_tokens
t_type	inc/minishell.h	/^}	t_type;$/;"	t	typeref:enum:e_type
t_utils	inc/minishell.h	/^}	t_utils;$/;"	t	typeref:struct:s_utils
tasks	.vscode/tasks.json	/^	"tasks": [$/;"	a
token	inc/minishell.h	/^	t_type			token;$/;"	m	struct:s_tokens	typeref:typename:t_type
trace	.vscode/launch.json	/^		  "trace": true$/;"	b	object:configurations.0.logging
type	.vscode/launch.json	/^		"type": "cppdbg",$/;"	s	object:configurations.0
type	.vscode/tasks.json	/^		"type": "shell",$/;"	s	object:tasks.0
value	inc/minishell.h	/^	char			*value;$/;"	m	struct:s_env	typeref:typename:char *
value	inc/minishell.h	/^	char			*value;$/;"	m	struct:s_tokens	typeref:typename:char *
version	.vscode/launch.json	/^	"version": "0.2.0",$/;"	s
version	.vscode/tasks.json	/^	"version": "2.0.0",$/;"	s
